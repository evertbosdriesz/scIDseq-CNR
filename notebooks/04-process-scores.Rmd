---
title: "Regressing with cell state scores"
author: "Evert Bosdriesz"
date: "`r Sys.Date()`"
output: 
  html_document:
    df_print: paged
    code_folding: hide
editor_options:
  markdown:
    wrap: sentence
bibliography: references.bib
---

```{r knitr_init, echo=FALSE, cache=FALSE, message=FALSE}
library(knitr)
library(rmdformats)
library(tidyverse)
# library(tidymodels)
library(here)

source(here("src", "graphics-options.R"))

## Global options
options(max.print = "80")
opts_chunk$set(
  echo = TRUE, cache = FALSE, prompt = FALSE, tidy = FALSE, comment = NA,
  message = FALSE, warning = FALSE
)
opts_knit$set(width = 80)
```

In this notebook we explore the interaction between cell process scores and drug treatments.

```{r load_data}
css <- read_tsv(here("results", "scIDseq", "cell_state_scores_all_treatments.tsv"))

signaling_pathways <- str_subset(colnames(css), "_signalling")
cellular_processes <- c("adhesion", "proliferation", "differentiation")

dat <- css %>% 
  mutate(
    cluster = as_factor(cluster),
    treatment = factor(treatment, levels = c("EGF", "ip70S6K_EGF", "iRSK_EGF"))
  ) %>% 
  pivot_longer(
    all_of(c(signaling_pathways, cellular_processes)),
    names_to = "process_name", values_to = "process_score"
    ) 

rm(css)

```

First, what is the distribution of the process scores?

```{r splot_core_distribution}
ggplot(dat, aes(x = process_score, color = process_name)) +
  geom_density() +
  facet_wrap(~process_name, scales = "free") +
  my_theme +
  theme(legend.position = "none")
```

This looks fairly normally distributed for each process.
Note the the absolute scales of the processes differs considerably.

```{r plot_process}
plot_process <- function(process) {
  ggplot(
    filter(dat, process_name == process),
    aes(x = cluster, y = process_score, color = treatment)
  ) +
    geom_boxplot(outlier.shape = 21) +
    #expand_limits(y = 0) +
    scale_color_manual(values = col_lst) +
    labs(title = process, x = "Cell state cluster", y = "Process score") +
    my_theme 
}
```

## Signaling pathway activity against treatment and cell state cluster.

We will first explore to what extent the cell-state cluster and treatment affect the cell process scores.
Specifically, we want to see if there are any interactions between these.
That means, whether the response of the "activity" of a pathway/process to a drug treatments depends on the cell state clusters.

We will study this by regressing the process scores against the treatments and cell state clusters, including an interaction term, using the following model

$$score_{i,x} \~ \beta_0 + \beta_{t}*treatment + \beta_{c}*cellstate + \beta_{i}*treatment * cellstate$$

and look for processes for which the interaction term is significant.
(We do not study the main effects here.) We'll consider the p-values using a two-way ANOVA because these are easiest to interpret.

```{r fit models}
get_fit <- function(process, df, formula){
  lm(formula, filter(df, process_name == process))
}

lst <- c(signaling_pathways, cellular_processes)
names(lst) <- lst
fit_lst_interaction <- purrr::map(lst, get_fit, dat, process_score ~ treatment*cluster)
fit_lst_simple      <- purrr::map(lst, get_fit, dat, process_score ~ treatment+cluster)
rm(lst)

model_interaction <- 
  purrr::map(fit_lst_interaction, broom::tidy) %>% 
  bind_rows(.id = "process_name") %>% 
  mutate(fdr = p.adjust(p.value, method = "BH")) %>% 
  mutate(term_type = case_when(
    str_detect(term, ":") ~ "interaction",
    str_detect(term, "(Intercept)") ~ "intercept",
    str_detect(term, "treatment") ~ "treatment",
    TRUE ~ "cluster"
  )) 

model_simple <- 
  purrr::map(fit_lst_simple, broom::tidy) %>% 
  bind_rows(.id = "process_name") %>% 
  mutate(fdr = p.adjust(p.value, method = "BH")) %>% 
  mutate(term_type = case_when(
    str_detect(term, ":") ~ "interaction",
    str_detect(term, "(Intercept)") ~ "intercept",
    str_detect(term, "treatment") ~ "treatment",
    TRUE ~ "cluster"
  )) 

rm(get_fit)

purrr::map(fit_lst_interaction, function(x) broom::tidy(anova(x))) %>% 
  bind_rows(.id = "process_name") %>% 
  filter(term == "treatment:cluster") %>% 
  mutate(fdr = p.adjust(p.value, method = "BH")) %>% 
  filter(fdr < 0.05) %>% 
  arrange(fdr) %>% 
  select(process_name, p.value, fdr)

```

Alternatively, we can look at which process-treatment-cluster triplets are significant by looking at the significance of the individual coefficients in the regression (but note that interpreting individual significance of interactions terms can be tricky).

```{r}
signif_interactions <-
  model_interaction %>% 
  filter(term_type == "interaction" & fdr < 0.05) %>%
  arrange(fdr) %>% 
  separate(term, into = c("treatment", "cluster"), sep = ":", remove = FALSE) %>% 
  mutate(
    treatment = stringr::str_replace(treatment, "treatment", ""),
    cluster = stringr::str_replace(cluster, "cluster", "")
  )
select(signif_interactions, process_name, treatment, cluster, estimate, p.value, fdr)

```

We find similar results, and see that this is mainly happening in cluster 8 and 9.

Let's visualize these.
In the plots below the model predictions for each treatment-cluster pair are indicated.
For comparison, the gray points indicate the estimates using a model without an interaction term.

```{r plot_predictions}
prediction_input <- distinct(select(dat, treatment, cluster)) %>% 
  arrange(cluster, treatment)

get_predictions <- function(fit){
  bind_cols(
    prediction_input,
    as_tibble(predict(fit, prediction_input, interval = "confidence")))
}

predictions_interaction <- 
  fit_lst_interaction %>% 
  purrr::map(get_predictions) %>% 
  bind_rows(.id = "process_name")


predictions_simple <- 
  fit_lst_simple %>% 
  purrr::map(get_predictions) %>% 
  bind_rows(.id = "process_name")

predictions <- bind_rows(list(
  "interaction" = predictions_interaction,
  "simple" = predictions_simple),
  .id = "model_type"
  ) 

rm(predictions_interaction, predictions_simple, prediction_input)

plot_prediction <- function(process){
  ggplot(filter(predictions, process_name == process & model_type == "interaction"), 
    aes(y = fit, x = cluster, color = treatment, group=treatment)) +
    geom_point(
      data = filter(predictions, process_name == process & model_type == "simple"),
      color = "lightgray", size = 4, position = position_dodge(width = 0.5)) +
     geom_errorbar(
      data = filter(predictions, process_name == process & model_type == "simple"),
      aes(y = fit, ymin = lwr, ymax = upr, group = treatment),
      width = .5, position = position_dodge(width = 0.5), color = "lightgray"
    ) +
    
    geom_point(size = 4, position = position_dodge(width = 0.5)) +
    
    geom_errorbar(
      aes(y = fit, ymin = lwr, ymax = upr, color = treatment),
      width = .5, position = position_dodge(width = 0.5)
    ) +
  scale_color_manual(values = col_lst) + 
  labs(title = process, x = "Cell state cluster", y = "Process score (Model estimate)") +
  my_theme
}

plot_prediction("BMP_signalling")
plot_prediction("JAK-STAT_signalling")
plot_prediction("adhesion")

```

## Antibody expression vs cellular process

Next, we analyze how cellular processes (adhesion, proliferation and differentiation) affect antibody expression, and if this influences the drug response.
Specifically, we will fit a linear model of the form: $$expresion \~ 0 + treat + diff + adh + prolif + treat*adh + treat*diff + treat*prolif $$

It is probably wise to exclude the antibodies that contribute to the differentiation, adhesion and proliferation score from this analysis.

```{r message=FALSE}
dat_tmm <- read_tsv(here("data", "processed", "scIDseq-vanEijl-tmm.tsv")) %>% 
  select(sample_id, treatment, ab_name, ab_type, ab_count_tmm) %>% 
  filter(treatment != "No_EGF") %>% 
  mutate(treatment = factor(treatment, levels = c("EGF", "ip70S6K_EGF", "iRSK_EGF")))


tmp <- select(dat, -cluster, -plate_number) %>% 
  filter(process_name %in% cellular_processes) %>% 
  pivot_wider(names_from = "process_name", values_from = "process_score") 
  
get_fit <- function(ab, df) {
  lm(
    ab_count_tmm ~ treatment*adhesion + treatment*proliferation + treatment*differentiation,
    data = filter(df, ab_name == ab)
  ) 
} 

lst <- unique(dat_tmm$ab_name)
names(lst) <- lst
fit_lst_processes <- purrr::map(lst, get_fit, left_join(dat_tmm, tmp, by = c("sample_id", "treatment")))


purrr::map(fit_lst_processes, function(x) broom::tidy(anova(x))) %>% 
  bind_rows(.id = "ab_name") %>%
  filter(str_detect(term, ":")) %>% 
  mutate(fdr = p.adjust(p.value, method = "BH")) %>% 
  arrange(fdr) %>% 
  filter(fdr < 0.05) %>% 
  select(ab_name, term, p.value, fdr)

rm(get_fit, tmp, lst)

```

Let's have a look at the most significant interactions.
CMYC is lower in under p70 and RSK inhibition (as expected), but this effect dissapears for cells with a high adhesion score, specifically for iRKS.

```{r plot CMYC}
interactions::interact_plot(
  fit_lst_processes$CMYC, pred = "adhesion", modx = "treatment", 
  plot.points = TRUE, interval = TRUE)
```

STAT1 and p-SMAD are part of the cellular state score, so we don't consider these.
LRP6-p shows a similar trend as CMYC.

```{r}
interactions::interact_plot(
  fit_lst_processes$LRP6_P, pred = "adhesion", modx = "treatment", 
  plot.points = TRUE, interval = TRUE)
```

IKBA phosphorylation increases with increasing differentiation under inhibitor treatement, but decrease in the absence of it.

```{r}
interactions::interact_plot(
  fit_lst_processes$IKBA_P, pred = "differentiation", modx = "treatment", 
  plot.points = TRUE, interval = TRUE)
```

JNK phosphorylation decreases with increasing adhesion score, but only in the absence of an inhibitor

```{r}
interactions::interact_plot(
  fit_lst_processes$JNK_P, pred = "adhesion", modx = "treatment", 
  plot.points = TRUE, interval = TRUE)
```


## Session info

```{r sessioninfo}
sessioninfo::session_info()
```
